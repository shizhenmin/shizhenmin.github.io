---
title: WGCNA学习笔记
categories: 生信
tags: WGCNA 生信 笔记
---

* content
{:toc}
## 安装

```
> install.packages("BiocManager")
> BiocManager::install("WGCNA")
The downloaded binary packages are in
	C:\Users\User\AppData\Local\Temp\Rtmp0wRUAZ\downloaded_packages
```





## 1、数据预处理

加载表达数据，并进行预处理（删除离群数据和空值）。

#### 1a. 加载表达数据

先对R环境做一些设置，载入WGCNA。读取 `LiverFemale3600.csv` 文件，将内容存到列表变量 `femData` 中。

```R
# Display the current working directory
getwd();
# If necessary, change the path below to the directory where the data files are stored.
# "." means current directory. On Windows use a forward slash / instead of the usual \.
workingDir = "D:/workspace/1-FemaleLiver/FemaleLiver-Data/"; #自己的目录
setwd(workingDir);
# Load the WGCNA package
library(WGCNA);
# The following setting is important, do not omit.
options(stringsAsFactors = FALSE);    #防止将导入的数据转换成因子
#Read in the female liver data set
femData = read.csv("LiverFemale3600.csv");
# Take a quick look at what is in the data set:
dim(femData);    #显示行数和列数
names(femData);    #显示每列的名字
```

该文件中每一行代表一个基因，每一列代表一个样本（老鼠）或者附加的信息（前8列）。删除文件中附加的信息，并将行和列调换一下，将新内容存到列表变量 `datExpr0` 中。

```R
datExpr0 = as.data.frame(t(femData[, -c(1:8)]));    #去掉1到8列的内容，并将行和列颠倒
names(datExpr0) = femData$substanceBXH;    #给列取名字，MMT00000044等，是3600个基因的名字
rownames(datExpr0) = names(femData)[-c(1:8)];    #给行取名字，F2_2等，是老鼠的名字
```



#### 1b. 数据过滤，删除空值和异常值

首先检查基因或样本的数据中是否有空值：

```R
gsg = goodSamplesGenes(datExpr0, verbose = 3);    #判断是否有缺失值
gsg$allOK;    #如果有缺失值，最后返回FALSE
```

如果有，将这样的数据删除：

```R
if (!gsg$allOK)    #如果有缺失值，则删除该值
{
  # Optionally, print the gene and sample names that were removed:
  if (sum(!gsg$goodGenes)>0) 
     printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")));
  if (sum(!gsg$goodSamples)>0) 
     printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")));
  # Remove the offending genes and samples from the data:
  datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
}
```

接着，通过聚类的方法看是否有异常值。

```R
sampleTree = hclust(dist(datExpr0), method = "average");    #聚类
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
sizeGrWindow(12,9);    #定义画布大小
#pdf(file = "Plots/sampleClustering.pdf", width = 12, height = 9);
par(cex = 0.6);    #缩小缺省状态下符号和文字的大小
par(mar = c(0,4,2,0));    #控制从轴到图形边界的4个值（下、左、上、右）
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, 
     cex.axis = 1.5, cex.main = 2);    #cex.lab坐标轴，cex.axis坐标轴上的数字，cex.main主标题
```

比如该数据中样本`F2_221`为异常值，设置15为阈值，通过`cutreeStatic`等方法删除该值，将新内容存到列表变量`datExpr`中。

```R
# Plot a line to show the cut
abline(h = 15, col = "red");    #绘制高为15的红色线
# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = 15, minSize = 10);    #过滤掉异常值，即高于15的值
table(clust);    #生成频数表，统计0和1的个数
# clust 1 contains the samples we want to keep.
keepSamples = (clust == 1);    #将值为0的标记为FALSE，值为1的标记为TRUE
datExpr = datExpr0[keepSamples, ];    #只保留TRUE的值
nGenes = ncol(datExpr);    #列数，即基因的个数
nSamples = nrow(datExpr);    #行数，即样本（老鼠）的个数
```

![WGCNA 11-1 sampleClust](D:\OneDrive - zju.edu.cn\program\GitHub\shizhenmin.github.io\images\bioinformatics\WGCNA 11-1 sampleClust.png)



#### 1c. 加载临床特征数据

读取`ClinicalTraits.csv`文件，将内容存到列表变量`traitData`中。

```R
traitData = read.csv("ClinicalTraits.csv");
dim(traitData);
names(traitData);
```

删除不需要的信息（第1列，第3到第10列，第16列，第31列），将新内容存到列表变量`allTraits`中。

```R
allTraits = traitData[, -c(31, 16)];    #删除第16、第31列，这两列值大部分为NA
allTraits = allTraits[, c(2, 11:36) ];    #取第2列、第11到36列
dim(allTraits);
names(allTraits);
```

通过`match`函数找到表达数据中的134只老鼠对应的数据，将新内容存到列表变量`datTraits`中。

```R
femaleSamples = rownames(datExpr);    #获得datExpr中的列名（134只老鼠的名字）
traitRows = match(femaleSamples, allTraits$Mice);    #在allTraits中找134只老鼠所在的位置
datTraits = allTraits[traitRows, -1];    #将134只老鼠挑选出来，去掉老鼠的名字
rownames(datTraits) = allTraits[traitRows, 1];    #给每行取老鼠的名字

collectGarbage();
```

之后通过`plotDendroAndColors`函数将临床特征数据和系统树进行可视化。在图中，白色表示数值低，红色表示数值高，灰色表示数值缺失。

```R
# Re-cluster samples
sampleTree2 = hclust(dist(datExpr), method = "average");    #聚类
# Convert traits to a color representation: white means low, red means high, grey means missing entry
traitColors = numbers2colors(datTraits, signed = FALSE);    #根据datTraits的值来创建颜色
# Plot the sample dendrogram and the colors underneath.
plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = names(datTraits), 
                    main = "Sample dendrogram and trait heatmap");    #绘制层次聚类树形图和下方的热图
```

最后一步将R.data保存。

```R
save(datExpr, datTraits, file = "FemaleLiver-01-dataInput.RData");    #保存文件，只保留datExpr和datTraits
```









## 2、网络构建

### 1 选择软阈值 β

计算softpower：

```R
# Choose a set of soft-thresholding powers
powers=c(c(1:10), seq(from=12, to=20, by=2));
# Call the network topology analysis function
sft=pickSoftThreshold(datExpr, powerVector = powers, verbose = 5); 
# $powerEstimate is 6
sft$powerEstimate;
```

导出 `sft$fitIndices`：

```R
write.csv(sft$fitIndices, "scaleFreeTopologyFitIndices.csv",row.names=FALSE)
```

画图，软阈值选择与无尺度网络适应度：

```R
# PNG
png("scaleFreeTopologyModelFit.png");
plot(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2], 
     xlab="Soft Threshold (power)", 
     ylab="Scale Free Topology Model Fit, signed R^2", 
     type="n");
text(sft$fitIndices[,1], 
     -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,
     col="red");
abline(h=0.90, col="red");
title("Scale Free Topology Model Fit");
dev.off();
```

![WGCNA 12-1 sftModelFit](\images\bioinformatics\WGCNA 12-1 sftModelFit.png)



画图，软阈值选择与连接度平均值：

```R
# PNG
png("MeanConnectivity.png");
plot(sft$fitIndices[,1], 
     sft$fitIndices[,5],
     xlab="Soft Threshold (power)",
     ylab="Mean Connectivity", 
     type="n");
text(sft$fitIndices[,1], 
     sft$fitIndices[,5], 
     labels=powers, 
     col="red");
abline(h=0.90, col="red");
title("Mean connectivity");
dev.off();
```

![WGCNA 12-1 sftModelFit](\images\bioinformatics\WGCNA 12-2 MeanConnectivity.png)

### 2 划分模块-构建网络

一步鉴定模块，结果在net$colors（用数字表示），net$MEs，net$dendrograms[[1]] （树）中。结果生成18个模块及1个未分配的模块

```R
net = blockwiseModules(datExpr, 
                       power = sft$powerEstimate,
                       TOMType = "unsigned", 
                       minModuleSize = 30,
                       reassignThreshold = 0, 
                       mergeCutHeight = 0.25,
                       numericLabels = TRUE, 
                       pamRespectsDendro = FALSE,
                       saveTOMs = TRUE,
                       saveTOMFileBase = "femaleMouseTOM", 
                       verbose = 3)
moduleLabels = net$colors
moduleColors = labels2colors(net$colors)
geneTree = net$dendrograms[[1]]
MEs = orderMEs(net$MEs)
modNames = labels2colors(as.numeric(substring(names(MEs), 3)))
names(MEs) = modNames
```



模块内基因数量统计：

```R
write.csv(table(moduleColors), "geneNumberInModule.csv",row.names = F)
```



统计基因属于哪个模块：

```R
geneNames = names(datExpr)
gene2module = data.frame(geneNames,moduleLabels,moduleColors,row.names = NULL)
write.csv(gene2module, "gene2module.csv",row.names = F)
```



基因树状图和模块颜色：

```R
pdf("geneClusterAndModuleColor.pdf")
plotDendroAndColors(geneTree,
                    moduleColors,
                    "Module colors",
                    dendroLabels = FALSE, 
                    hang = 0.03,
                    addGuide = TRUE, 
                    guideHang = 0.05)
dev.off();
```



模块热图：

```R
pdf("moduleHeatmap.pdf")
plotEigengeneNetworks(MEs, "Eigengene adjacency heatmap", plotDendrograms = FALSE, xLabelsAngle = 90, marHeatmap = c(6,6,6,4))
dev.off();
```



模块树：

```R
pdf("moduleDendrogram.pdf")
plotEigengeneNetworks(MEs, "Eigengene dendrogram", marDendro = c(0,4,2,0), plotHeatmaps = FALSE);
dev.off()
```



导出模块ME与样本关系的表格：

```
write.csv(MEs, "MEs.csv")
```



模块表达热图：

```R
for (module in modNames)
{
  fileName = paste("geneExpressionOf_", module, "_Module.pdf", sep="")
  pdf(fileName)
  keepModuleGenes = (moduleColors == module);
  plotMat(t(scale(datExpr[,keepModuleGenes])),
          nrgcols=30,
          rlabels=T, rcols=module,
          clabels=T, 
          title=module)
  dev.off()
}
```



模块ME与样本关系柱状图：

```R
for (module in modNames)
{
  fileName = paste("MEsExpressionOf_", module, "_Module.pdf", sep="")
  pdf(fileName)
  barplot(MEs[,module], col=module, main=paste("Eigengene expression of", module, "module"))
  dev.off()
}
```



模块相关性：

```R
pdf("advancedMEcorPlot.pdf")
plotMEpairs(datME,y = NULL)
dev.off()

png("advancedMEcorPlot.png")
plotMEpairs(datME,y = NULL)
dev.off()
```



### 3 计算MM

```R
geneMM = as.data.frame(cor(datExpr, MEs, use = "p"));
nSamples = nrow(datExpr);
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneMM), nSamples));
```



### 4 计算连接度

计算基因在整个网络中的连接度kTotal，模块内的连接度kWithin，模块外的连接度kOut，模块内外连接度差kDiff。

```R
similarityMatrix = abs(cor(datExpr, use = "p"));
adjacencyMatrix = similarityMatrix^sft$powerEstimate;
Alldegrees=intramodularConnectivity(adjacencyMatrix, moduleColors);
```

输出基因连接度：

```R
AllGene = '';
for (module in modNames)
{
  keepModuleGenes = (moduleColors == module);
  moduleGeneMM = data.frame(module = module, 
                            geneID = rownames(geneMM[keepModuleGenes,]), 
                            MM = geneMM[keepModuleGenes, module], 
                            MMPvalue = MMPvalue[keepModuleGenes, module],
                            kTotal = Alldegrees[keepModuleGenes, 'kTotal'],
                            kWithin = Alldegrees[keepModuleGenes, 'kWithin'],
                            kOut = Alldegrees[keepModuleGenes, 'kOut'],
                            kDiff = Alldegrees[keepModuleGenes, 'kDiff']);
  write.csv(moduleGeneMM, file = paste(module, "_GeneMM.P.K.csv", sep=''), row.names = F);
  AllGene = rbind(AllGene, moduleGeneMM)
}
AllGene = AllGene[-1,]
write.csv(AllGene, file = "AllGeneMM.P.K.csv", row.names = F);
```



基因连接度与ME：

```R
for (module in modNames)
{
  pdf(paste(module, "_GeneMMvsConnectivity.pdf", sep=''))
  keepModuleGenes = (moduleColors == module);
  verboseScatterplot(Alldegrees$kWithin[keepModuleGenes],
                     (geneMM[keepModuleGenes, module])^6,
                     col=module,
                     main=module,
                     xlab="Intramodular Connectivity",
                     ylab="(Module Membership)^6")
  dev.off()
}
```





```R

```



```R

```





```R

```



```R

```



```R

```



```R

```



```R

```



```R

```





```R

```



```R

```







## 3、模块划分





## 4、模块内分析





## 5、表型关联